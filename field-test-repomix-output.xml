This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.repomixignore
CHANGELOG.md
docs/PRD.md
docs/SPEC.md
package.json
packages/shared/package.json
packages/shared/src/index.ts
packages/shared/src/types.ts
packages/shared/src/utils.ts
packages/shared/tsconfig.json
packages/shared/tsup.config.ts
packages/validation-lib/package.json
packages/validation-lib/README.md
packages/validation-lib/src/cli.ts
packages/validation-lib/src/index.ts
packages/validation-lib/src/schemas.ts
packages/validation-lib/tsconfig.json
packages/validation-lib/tsup.config.ts
README.md
repomix.config.json
src/fieldtest-schema.json
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to the fieldtest workspace will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added

- Initial project setup with PNPM workspaces and Turborepo
- Core validation library (@fieldtest/validation-lib) with Zod integration
- Integration with @docs-score/core functionality
- CLI interface for validating content from the command line
- Common validation schemas for documents, URLs, and configurations

### Changed

- N/A

### Fixed

- N/A

## [0.1.0] - 2025-05-02

### Added - 0.1.0

- Initial workspace structure
- Package and directory scaffolding
- Basic documentation

[Unreleased]: https://github.com/yourorg/fieldtest/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/yourorg/fieldtest/releases/tag/v0.1.0
</file>

<file path="docs/PRD.md">
# FieldTest – Product Requirements Document

## Summary

**FieldTest** is a modular schema validation toolkit for content-rich websites and apps. It ensures structural consistency across Markdown files, CMS payloads, and other content formats using a shared validation layer based on [Zod](https://zod.dev/) and [Standard Schema](https://standardschema.dev/).

It is designed for modern frameworks like **Astro** and **Next.js**, with support for both local CLI tooling and CI/CD integrations.

---

## Goals

- ✅ Prevent runtime layout regressions from schema mismatches
- ✅ Catch missing/undefined fields early in dev or CI
- ✅ Make content types auditable and testable like code
- ✅ Support LLM-readable content definitions (e.g. `llms.txt`)
- ✅ Enable safe collaboration between developers and content teams

---

## Key Deliverables

- [x] `@schemas` shared module (Zod-based)
- [x] CLI tool: `fieldtest validate`
- [x] GitHub Action for schema enforcement
- [x] Web dashboard `/validate` (in Astro or Next)
- [x] Support `llms.txt` validation
- [ ] VS Code Extension (inline decorators, type hints)
- [ ] FieldTest Cloud (hosted dashboard + notifications)

---

## Success Criteria

- CLI and GitHub Action detect breaking schema changes before runtime
- Markdown and CMS data can be validated locally or in CI
- Works seamlessly in both Astro and Next.js with minimal config
- Schema definitions are reusable, typed, and extensible
- Devs adopt FieldTest across multiple content-focused projects

---

## Target Users

- Frontend developers using Markdown or CMS data
- DevOps or platform engineers managing CI
- Technical content teams looking to avoid accidental structure drift
</file>

<file path="docs/SPEC.md">
# FieldTest – Technical Specification

## Architecture

```md
packages/
├── fieldtest/         # Core schema library (Zod-based)
├── fieldtest/apps/    # Astro or Next.js apps
│   ├── src/
│   │   ├── index.ts   # Export all shared Zod schemas
│   │   ├── cli.ts     # CLI entry point
│   │   ├── validate.ts
│   │   └── utils/
│   └── package.json
├── web-dashboard/     # Astro or Next.js web dashboard (optional)
├── fieldtest-action/  # GitHub Action entrypoint
pnpm-workspace.yaml
```

---

## CLI Tool

- Command: `fieldtest validate`
- Accepts config or paths to content + schema modules
- Outputs validation errors, missing fields, suggestions
- Optional JSON output for GitHub annotations

```bash
fieldtest validate \
  --schema ./schemas/post.schema.ts \
  --content ./content/blog
````

---

## Schema Format

- All schemas use **Zod** (with inference support)
- Schemas follow a common `FieldTestSchema` interface
- Support for inheritance/extension across projects
- Optional support for `.schema.json` generation

---

## GitHub Action

- Runs `fieldtest validate` on push or PR
- Fails build on schema violations
- Annotates PRs with schema errors (future)

---

## Dashboard (`/validate`)

- Lists all registered schemas
- Upload or paste content for validation
- Shows diffs for schema changes over time
- Supports schema previews and documentation links

---

## IDE Integration (Future)

- VS Code extension using Language Server Protocol
- Inline decorators for fields with schema violations
- Auto-suggestions based on schema constraints

---

## Compatibility Targets

- Astro (ESM, Markdown-first)
- Next.js (App router & Pages router)
- Markdown/MDX (via `gray-matter` or unified/remark)
- Headless CMS (Sanity, Contentful, etc.)
- JSON data (from REST or GraphQL)

---

## Configuration

```ts
// fieldtest.config.ts
export default {
  contentGlob: "content/**/*.md",
  schemaGlob: "schemas/**/*.ts",
  validateLLMS: true
}
```

---

## Open Questions

- Should `FieldTest` generate type definitions or just validate?
- Should dashboards allow schema editing in the browser?
- Should we offer a "FieldTest Cloud" for hosted validation and diffs?

---

## Tech Stack

- **Zod** for runtime + inferred type safety
- **Tsup** for bundling CLI + lib
- **pnpm workspaces** for modular development
- **Vitest** for test coverage
- **Astro/Next.js** for dashboard
- **Bun** optional for fast CLI runs
- **GitHub Actions** for CI validation
</file>

<file path="package.json">
{
  "name": "fieldtest",
  "version": "0.1.0",
  "private": true,
  "description": "TypeScript validation tools that work with both Astro and Next.js",
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint",
    "test": "turbo run test",
    "clean": "turbo run clean"
  },
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "dependencies": {
    "@docs-score/core": "link:../docs-score.com/packages/core"
  },
  "devDependencies": {
    "turbo": "^2.1.0",
    "typescript": "^5.3.0"
  }
}
</file>

<file path="packages/shared/package.json">
{
  "name": "@fieldtest/shared",
  "version": "0.1.0",
  "description": "Shared utilities and types for fieldtest",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "require": "./dist/index.js",
      "import": "./dist/index.mjs",
      "types": "./dist/index.d.ts"
    }
  },
  "files": [
    "dist/**"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "lint": "eslint src/**/*.ts",
    "test": "vitest run",
    "clean": "rimraf dist"
  },
  "dependencies": {
    "@docs-score/core": "workspace:*",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "eslint": "^8.56.0",
    "rimraf": "^5.0.5",
    "tsup": "^8.0.0",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0"
  }
}
</file>

<file path="packages/shared/src/index.ts">
/**
 * @fieldtest/shared
 *
 * Shared utilities and types for fieldtest applications
 */

export * from "./types";
export * from "./utils";
export * from "./constants";
</file>

<file path="packages/shared/src/types.ts">
/**
 * Common types for the fieldtest workspace
 */

import { z } from "zod";
import { type Issue, type MetricResult } from "@docs-score/core";

/**
 * Common validation result interface
 */
export interface ValidationResult<T> {
  isValid: boolean;
  data?: T;
  errors?: Array<{
    path: string;
    message: string;
  }>;
}

/**
 * Report format for validation results
 */
export interface ValidationReport {
  timestamp: string;
  url: string;
  results: Record<string, ValidationResult<unknown>>;
  issues: Issue[];
  metrics?: Record<string, MetricResult>;
  summary: {
    valid: number;
    invalid: number;
    total: number;
  };
}

/**
 * Framework types for better integration with Astro and Next.js
 */
export enum Framework {
  Astro = "astro",
  NextJS = "nextjs",
  Unknown = "unknown",
}

/**
 * Configuration options for the validation library
 */
export interface ValidationOptions {
  /**
   * The maximum depth to crawl
   * @default 3
   */
  maxDepth?: number;

  /**
   * The concurrency limit for crawling
   * @default 5
   */
  concurrency?: number;

  /**
   * Paths or patterns to ignore
   */
  ignore?: string[];

  /**
   * Whether to validate URLs
   * @default true
   */
  validateUrls?: boolean;

  /**
   * Whether to validate heading structure
   * @default true
   */
  validateHeadings?: boolean;

  /**
   * Whether to validate document structure
   * @default true
   */
  validateDocuments?: boolean;

  /**
   * The framework being used (for framework-specific validations)
   */
  framework?: Framework;
}
</file>

<file path="packages/shared/src/utils.ts">
/**
 * Common utility functions
 */

import { z } from "zod";
import { type ValidationResult, type Framework } from "./types";

/**
 * Convert a ZodError to a ValidationResult
 */
export function zodErrorToValidationResult<T>(
  error: z.ZodError
): ValidationResult<T> {
  return {
    isValid: false,
    errors: error.errors.map((err) => ({
      path: err.path.join("."),
      message: err.message,
    })),
  };
}

/**
 * Format a validation error for display
 */
export function formatValidationError(error: {
  path: string | string[];
  message: string;
}): string {
  const pathStr = Array.isArray(error.path) ? error.path.join(".") : error.path;

  return `${pathStr ? `${pathStr}: ` : ""}${error.message}`;
}

/**
 * Detect the framework being used
 */
export function detectFramework(): Framework {
  try {
    // Check for Astro
    if (typeof import.meta.env !== "undefined") {
      return "astro";
    }

    // Check for Next.js
    if (
      (typeof process !== "undefined" && process.env.NEXT_PUBLIC_VERCEL_URL) ||
      process.env.__NEXT_RUNTIME
    ) {
      return "nextjs";
    }

    return "unknown";
  } catch (error) {
    return "unknown";
  }
}

/**
 * Create a validation summary
 */
export function createValidationSummary(
  results: Record<string, ValidationResult<unknown>>
): {
  valid: number;
  invalid: number;
  total: number;
} {
  const validCount = Object.values(results).filter(
    (result) => result.isValid
  ).length;
  const totalCount = Object.keys(results).length;

  return {
    valid: validCount,
    invalid: totalCount - validCount,
    total: totalCount,
  };
}

/**
 * Safe JSON parse with validation
 */
export function safeJsonParse<T>(
  json: string,
  schema: z.ZodType<T>
): ValidationResult<T> {
  try {
    const parsed = JSON.parse(json);
    try {
      const valid = schema.parse(parsed);
      return {
        isValid: true,
        data: valid,
      };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return zodErrorToValidationResult<T>(error);
      }
      throw error;
    }
  } catch (error) {
    return {
      isValid: false,
      errors: [
        {
          path: "",
          message: `Invalid JSON: ${
            error instanceof Error ? error.message : String(error)
          }`,
        },
      ],
    };
  }
}
</file>

<file path="packages/shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["es2020"],
    "module": "esnext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "."
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
</file>

<file path="packages/shared/tsup.config.ts">
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  clean: true,
  sourcemap: true,
  splitting: false,
  shims: true,
  treeshake: true,
});
</file>

<file path="packages/validation-lib/package.json">
{
  "name": "@fieldtest/validation-lib",
  "version": "0.1.0",
  "description": "Reusable TypeScript validation library using Zod schemas",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "require": "./dist/index.js",
      "import": "./dist/index.mjs",
      "types": "./dist/index.d.ts"
    },
    "./cli": {
      "require": "./dist/cli.js",
      "import": "./dist/cli.mjs",
      "types": "./dist/cli.d.ts"
    }
  },
  "bin": {
    "validate": "./dist/cli.js"
  },
  "files": [
    "dist/**"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "lint": "eslint src/**/*.ts",
    "test": "vitest run",
    "test:watch": "vitest",
    "clean": "rimraf dist"
  },
  "dependencies": {
    "@docs-score/core": "workspace:*",
    "@fieldtest/shared": "workspace:*",
    "zod": "^3.22.4",
    "commander": "^12.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "eslint": "^8.56.0",
    "rimraf": "^5.0.5",
    "tsup": "^8.0.0",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0"
  }
}
</file>

<file path="packages/validation-lib/README.md">
# @fieldtest/validation-lib

A TypeScript validation library that works with both Astro and Next.js applications, building on top of Zod and integrated with @docs-score/core.

## Features

- **Framework Agnostic**: Works with both Astro and Next.js
- **Zod Integration**: Built on top of Zod for powerful schema validation
- **@docs-score/core Integration**: Leverages existing validation from @docs-score/core
- **CLI Interface**: Command-line tools for validation
- **Common Schemas**: Pre-built schemas for common validation needs
- **Type Safety**: Full TypeScript support with inferred types

## Installation

```bash
# If you're in the monorepo
pnpm add @fieldtest/validation-lib

# If you're outside the monorepo
npm install @fieldtest/validation-lib
```

## Usage

### Basic Validation

```typescript
import { validate, z } from '@fieldtest/validation-lib';

const schema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().min(18)
});

const userData = {
  name: "Alice",
  email: "alice@example.com",
  age: 25
};

const [isValid, result] = validate(schema, userData);

if (isValid) {
  console.log("Valid data:", result);
} else {
  console.error("Invalid data:", result.errors);
}
```

### Using Pre-defined Schemas

```typescript
import { validate, DocumentSchema } from '@fieldtest/validation-lib';

const document = {
  title: "Getting Started",
  url: "https://example.com/docs/getting-started",
  headings: [
    { level: 1, text: "Getting Started" },
    { level: 2, text: "Installation" }
  ]
};

const [isValid, result] = validate(DocumentSchema, document);

if (!isValid) {
  console.error("Invalid document structure");
}
```

### Integration with @docs-score/core

```typescript
import { scanSite } from '@docs-score/core';
import { validate, ScanOptionsSchema } from '@fieldtest/validation-lib';

const options = {
  entry: "https://example.com",
  maxDepth: 3,
  concurrency: 5
};

const [isValid, validatedOptions] = validate(ScanOptionsSchema, options);

if (isValid) {
  const results = await scanSite(validatedOptions);
  console.log(`Scanned ${results.pages.length} pages`);
}
```

### CLI Usage

```bash
# Validate a URL
npx validate url https://example.com --depth 3 --concurrency 5 --output results.json

# Validate a configuration file
npx validate config ./config.json --schema ValidationConfig
```

## API Reference

### Core Functions

- `validate<T>(schema: z.ZodType<T>, input: unknown): [boolean, T | z.ZodError]`
- `validateAsync<T>(schema: z.ZodType<T>, input: unknown): Promise<[boolean, T | z.ZodError]>`
- `formatZodError(error: z.ZodError): string`

### Pre-defined Schemas

- `URLSchema`: Validates URLs
- `EmailSchema`: Validates email addresses
- `DocumentSchema`: Validates document structure
- `ValidationConfigSchema`: Validates configuration files
- `ScanOptionsSchema`: Validates @docs-score/core scan options

## License

MIT
</file>

<file path="packages/validation-lib/src/cli.ts">
#!/usr/bin/env node

/**
 * Validation CLI
 *
 * Command-line interface for validating content using schemas from our validation library
 */

import { Command } from "commander";
import { z } from "zod";
import fs from "fs";
import path from "path";
import { scanSite } from "@docs-score/core";
import { validate, formatZodError, ScanOptionsSchema } from "./index";

// Create a new Commander program
const program = new Command();

// Configure program metadata
program
  .name("validate")
  .description("Validate content using schemas from our validation library")
  .version("0.1.0");

// Command for validating a URL
program
  .command("url")
  .description("Validate a URL")
  .argument("<url>", "URL to validate")
  .option("-d, --depth <number>", "Maximum crawl depth", "3")
  .option("-c, --concurrency <number>", "Number of concurrent requests", "5")
  .option("-o, --output <file>", "Output file for validation results")
  .action(async (url, options) => {
    // Validate the options
    const optionsSchema = z.object({
      depth: z.preprocess(
        (val) => parseInt(val as string, 10),
        z.number().int().positive()
      ),
      concurrency: z.preprocess(
        (val) => parseInt(val as string, 10),
        z.number().int().positive()
      ),
      output: z.string().optional(),
    });

    const [isValid, parsedOptions] = validate(optionsSchema, options);

    if (!isValid) {
      console.error("Invalid options:");
      console.error(formatZodError(parsedOptions as z.ZodError));
      process.exit(1);
    }

    // Validate the URL and options using our schema
    const [isScanOptionsValid, scanOptions] = validate(ScanOptionsSchema, {
      entry: url,
      maxDepth: (parsedOptions as z.infer<typeof optionsSchema>).depth,
      concurrency: (parsedOptions as z.infer<typeof optionsSchema>).concurrency,
    });

    if (!isScanOptionsValid) {
      console.error("Invalid scan options:");
      console.error(formatZodError(scanOptions as z.ZodError));
      process.exit(1);
    }

    try {
      console.log(`Validating ${url}...`);
      const result = await scanSite(scanOptions as any);

      console.log(`\nValidation complete!`);
      console.log(`Found ${result.pages.length} pages`);

      // Write the results to a file if output is specified
      if ((parsedOptions as z.infer<typeof optionsSchema>).output) {
        const outputFile = (parsedOptions as z.infer<typeof optionsSchema>)
          .output as string;
        fs.writeFileSync(
          path.resolve(process.cwd(), outputFile),
          JSON.stringify(result, null, 2)
        );
        console.log(`Results written to ${outputFile}`);
      }
    } catch (error) {
      console.error("Error validating URL:");
      console.error(error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  });

// Command for validating a JSON config file
program
  .command("config")
  .description("Validate a configuration file")
  .argument("<file>", "Path to configuration file")
  .option(
    "-s, --schema <name>",
    "Schema to validate against",
    "ValidationConfig"
  )
  .action((file, options) => {
    try {
      const configFile = path.resolve(process.cwd(), file);
      const configContent = fs.readFileSync(configFile, "utf-8");
      const configData = JSON.parse(configContent);

      // Import the schema dynamically based on the name
      import("./schemas")
        .then((schemas) => {
          const schemaName = `${options.schema}Schema`;
          const schema = schemas[schemaName];

          if (!schema) {
            console.error(`Schema ${schemaName} not found`);
            process.exit(1);
          }

          const [isValid, result] = validate(schema, configData);

          if (isValid) {
            console.log(`Configuration file ${file} is valid!`);
          } else {
            console.error(`Configuration file ${file} is invalid:`);
            console.error(formatZodError(result as z.ZodError));
            process.exit(1);
          }
        })
        .catch((error) => {
          console.error("Error importing schemas:");
          console.error(error instanceof Error ? error.message : String(error));
          process.exit(1);
        });
    } catch (error) {
      console.error("Error reading or parsing configuration file:");
      console.error(error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  });

// Parse the command line arguments
program.parse();
</file>

<file path="packages/validation-lib/src/index.ts">
/**
 * @fieldtest/validation-lib
 *
 * A TypeScript validation library that works with both Astro and Next.js
 * Built on top of Zod and integrated with @docs-score/core
 */

import { z } from "zod";
import { type ScanOptions } from "@docs-score/core";

// Re-export Zod for convenience
export { z };

// Export common validation schemas
export * from "./schemas";

/**
 * Validates input against a schema and returns the result
 *
 * @param schema - The Zod schema to validate against
 * @param input - The input to validate
 * @returns A tuple containing validation success and parsed data or error
 */
export function validate<T>(
  schema: z.ZodType<T>,
  input: unknown
): [boolean, T | z.ZodError] {
  try {
    const result = schema.parse(input);
    return [true, result];
  } catch (error) {
    if (error instanceof z.ZodError) {
      return [false, error];
    }
    throw error;
  }
}

/**
 * Validates input asynchronously against a schema and returns the result
 *
 * @param schema - The Zod schema to validate against
 * @param input - The input to validate
 * @returns A Promise for a tuple containing validation success and parsed data or error
 */
export async function validateAsync<T>(
  schema: z.ZodType<T>,
  input: unknown
): Promise<[boolean, T | z.ZodError]> {
  try {
    const result = await schema.parseAsync(input);
    return [true, result];
  } catch (error) {
    if (error instanceof z.ZodError) {
      return [false, error];
    }
    throw error;
  }
}

/**
 * Formats a Zod error into a user-friendly message
 *
 * @param error - The Zod error to format
 * @returns A formatted error message
 */
export function formatZodError(error: z.ZodError): string {
  return error.errors
    .map((err) => {
      const path = err.path.join(".");
      return `${path ? `${path}: ` : ""}${err.message}`;
    })
    .join("\n");
}

// Integration with @docs-score/core
export const ScanOptionsSchema = z.object({
  entry: z.string().url(),
  maxDepth: z.number().int().positive().optional(),
  ignore: z.array(z.string()).optional(),
  concurrency: z.number().int().positive().optional(),
  delayBetweenRequests: z.number().int().nonnegative().optional(),
}) satisfies z.ZodType<ScanOptions>;

export type ValidatedScanOptions = z.infer<typeof ScanOptionsSchema>;
</file>

<file path="packages/validation-lib/src/schemas.ts">
/**
 * Common validation schemas
 */

import { z } from "zod";
import { type Issue, type MetricResult } from "@docs-score/core";

// Basic schemas
export const URLSchema = z.string().url();
export const EmailSchema = z.string().email();
export const DateSchema = z.coerce.date();
export const UUIDSchema = z.string().uuid();

// Content validation schemas
export const HeadingSchema = z.object({
  level: z.number().int().min(1).max(6),
  text: z.string().min(1),
  id: z.string().optional(),
});

export const LinkSchema = z.object({
  href: z.string().url(),
  text: z.string().min(1),
  external: z.boolean().optional(),
});

export const DocumentSchema = z.object({
  title: z.string().min(1),
  url: z.string().url(),
  headings: z.array(HeadingSchema),
  links: z.array(LinkSchema).optional(),
  lastModified: z.coerce.date().optional(),
});

// Post schema for blog posts
export const PostSchema = z.object({
  title: z.string().min(1),
  description: z.string().min(1),
  slug: z.string().min(1),
  published: z.boolean(),
});

// Issue schema for validation results
export const IssueSeveritySchema = z.enum(["error", "warning", "info"]);

export const IssueSchema = z.object({
  message: z.string(),
  severity: IssueSeveritySchema,
  url: z.string().url().optional(),
  element: z.string().optional(),
  fix: z.string().optional(),
  details: z.record(z.any()).optional(),
}) satisfies z.ZodType<Issue>;

// Metric result schema
export const MetricResultSchema = z.object({
  score: z.number().min(0).max(100),
  maxScore: z.number().positive(),
  issues: z.array(IssueSchema),
  details: z.record(z.any()).optional(),
}) satisfies z.ZodType<MetricResult>;

// Configuration schemas
export const ValidationConfigSchema = z.object({
  rules: z.record(
    z.object({
      enabled: z.boolean().default(true),
      severity: IssueSeveritySchema.default("warning"),
      options: z.record(z.any()).optional(),
    })
  ),
  ignore: z.array(z.string()).optional(),
});

export type ValidationConfig = z.infer<typeof ValidationConfigSchema>;
export type IssueSeverity = z.infer<typeof IssueSeveritySchema>;
export type Heading = z.infer<typeof HeadingSchema>;
export type Link = z.infer<typeof LinkSchema>;
export type Document = z.infer<typeof DocumentSchema>;

/**
 * Schema Registry - maps schema names to their Zod schemas
 */
const schemaRegistry: Record<string, z.ZodTypeAny> = {
  document: DocumentSchema,
  post: PostSchema,
};

/**
 * Validate content against a named schema
 */
export function validateSchema(
  content: unknown,
  schemaName: string
): { success: boolean; errors?: string[] } {
  const schema = schemaRegistry[schemaName];

  if (!schema) {
    return {
      success: false,
      errors: [`Schema "${schemaName}" not found in registry`],
    };
  }

  try {
    schema.parse(content);
    return { success: true };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.errors.map(
          (err) => `${err.path.join(".")}: ${err.message}`
        ),
      };
    }
    return {
      success: false,
      errors: ["Unknown validation error"],
    };
  }
}
</file>

<file path="packages/validation-lib/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["es2020"],
    "module": "esnext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "."
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
</file>

<file path="packages/validation-lib/tsup.config.ts">
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts", "src/cli.ts"],
  format: ["cjs", "esm"],
  dts: true,
  clean: true,
  sourcemap: true,
  splitting: false,
  shims: true,
  treeshake: true,
});
</file>

<file path="README.md">
# Fieldtest Workspace

A monorepo for TypeScript validation tools that work with both Astro and Next.js applications, leveraging @docs-score/core functionality.

## Overview

This workspace contains a set of packages and applications that demonstrate how to build validation tools that work seamlessly across different frontend frameworks. It showcases the integration with @docs-score/core and uses modern tools like PNPM workspaces, Turborepo, and tsup.

## Structure

The workspace is structured as follows:

```md
fieldtest/
├── apps/                # Applications
│   ├── astro-site/      # Astro.js application
│   └── next-app/        # Next.js application
├── packages/            # Shared packages
│   ├── shared/          # Common utilities and types
│   └── validation-lib/  # Core validation library
├── package.json         # Workspace configuration
└── turbo.json           # Turborepo configuration
```

## Key Features

- **Monorepo Setup**: Using PNPM workspaces and Turborepo for efficient package management
- **Framework Agnostic**: Libraries and utilities that work with both Astro and Next.js
- **@docs-score/core Integration**: Leveraging existing functionality from @docs-score/core
- **Modern Tooling**: Using tsup for bundling, Vitest for testing, and ESLint for linting
- **TypeScript**: Full TypeScript support with proper type definitions

## Getting Started

### Prerequisites

- Node.js 18+
- PNPM 8+

### Installation

```bash
# Install dependencies
pnpm install
```

### Development

```bash
# Start development servers for all applications
pnpm dev

# Build all packages and applications
pnpm build

# Run tests across all packages
pnpm test
```

## Key Packages

### @fieldtest/validation-lib

A TypeScript validation library that works with both Astro and Next.js, built on top of Zod and integrated with @docs-score/core. See the [validation-lib README](./packages/validation-lib/README.md) for more details.

## Applications

### Astro Site

A demo Astro.js site that showcases the validation library in action.

### Next.js App

A demo Next.js application that demonstrates how to use the validation library in a React application.

## Acknowledgements

This project is built on the foundations laid by the @docs-score/core library and inspired by the patterns described in the [NOTE.md](../NOTE.md) file.

## License

MIT
</file>

<file path="repomix.config.json">
{
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "field-test-repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src/fieldtest-schema.json">
{
  "name": "debugging-session",
  "schemaVersion": "1.0",
  "constraints": {
    "execution": {
      "maxTokens": 4096,
      "maxLatency": "2000ms",
      "maxMemory": "512MB"
    },
    "artifacts": {
      "diffSize": {
        "max": 80,
        "preferred": 40
      },
      "requiredOutput": ["patch", "explanation"]
    },
    "tools": {
      "required": ["typescript_analyzer"],
      "optional": ["git_patch", "test_runner"]
    },
    "memory": {
      "trace": "required",
      "persistence": "jsonl",
      "retention": "session"
    }
  },
  "assertions": [
    {
      "id": "output-validation",
      "expression": "output.includes('patch')",
      "severity": "error"
    },
    {
      "id": "memory-validation",
      "expression": "session.memory.contains('stacktrace')",
      "severity": "warning"
    },
    {
      "id": "performance",
      "expression": "session.duration < 5000",
      "severity": "info"
    }
  ],
  "metrics": {
    "successRate": "assertions.passed / assertions.total",
    "efficiency": "1 - (tokens.used / constraints.execution.maxTokens)",
    "precision": "custom.function('evaluatePatchQuality')"
  }
}
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": ["**/.env.*local"],
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**", "dist/**"]
    },
    "dev": {
      "cache": false,
      "dependsOn": ["^build"],
      "persistent": true
    },
    "lint": {},
    "test": {
      "dependsOn": ["build"]
    },
    "clean": {
      "cache": false
    }
  }
}
</file>

</files>
